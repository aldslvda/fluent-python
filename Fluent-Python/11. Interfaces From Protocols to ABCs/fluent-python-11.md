## Fluent Python ##
### Chapter 11. Interfaces From Protocols to ABCs
### 第十一章: 从协议到抽象基类

本章主要讨论接口，从鸭子类型的动态协议到使接口更加明确，能验证实现是否符合规定的抽象基类（ABC）

本章会专门讲解抽象基类。首先，本章说明抽象基类的常见用途：实现接口时作为超类使用。然后，说明抽象基类如何检查具体子类是否符合接口定义，以及如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。最后，说明如何让抽象基类自动“识别”任何符合接口的类——不进行子类化或注册。

#### 11.1 Python 中的接口和协议

Python中，我们把协议定为非正式的接口， 协议也是Python这类动态语言实现多态的方式。

Python 中接口的运作方式: Python 中没有interface 关键字， 并且除了抽象基类（ABC）,每个类都有接口，实现方式为：类实现或继承公开属性(方法或者数据属性)

关于接口有一个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定角色。
借口是实现特定角色的方法的集合，这就是协议。协议与继承没有关系，一个类可能实现多个接口使同一个实例扮演多个角色。

协议不是正式的接口, 没有接口一致性的各种强制，因此一个类可以只实现部分接口。


#### 11.2 Python中的序列协议

Python中数据模型的哲学是尽量支持基本协议， 下面的图展示了抽象基类Sequence的正式接口。

![Figure-11-1](https://raw.githubusercontent.com/aldslvda/blog-images/master/fluent-python-11-1.jpg)

如果没有实现\_\_iter\_\_和\_\_contains\_\_方法， Python会调用\_\_getitem\_\_方法， 设法让迭代和in运算符可用。几十一个对象只实现了\_\_getitem\_\_方法，也能进行迭代，为了迭代对象，解释器会尝试调用两个不同的方法。





