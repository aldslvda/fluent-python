## Fluent Python ##
### Chapter 13. Operator Overloading: Doing It Right
### 第十三章: 正确使用运算符重载

运算符重载的作用是让用户定义的对象使用中缀运算符或一元运算符。宽泛一些来讲，Python中的函数调用（()）,属性访问（.）,和元素访问/切片（[]）也是运算符，不过本章只讨论一元运算符和中缀运算符。

接下来我们会讨论这几个问题:

- Python中如何处理运算符中不同类型的操作数
- 使用压制类型或者显式类型检查处理不同类型的操作数
- 中缀运算符如何表明自己无法处理操作数
- 众多比较运算符(==, > ,<=)等的特殊行为
- 增量赋值运算符的默认处理方式和重载方式


#### 13.1 运算符重载基础

Python 在运算符重载方面进行了一些限制，做好了灵活性、可用性和安全性方面的平衡。

- 不能重载内置类型的运算符
- 不能新建运算符，只能使用现有的
- 某些运算符不能重载——is、and、or、not


#### 13.2 一元运算符

Python语言参考手册中，列出了3个一元运算符:

- \- 取负运算符，对应特殊方法 \_\_neg\_\_
- \+ 取正运算符，对应特殊方法 \_\_pos\_\_
- ~  取反运算符，对应特殊方法 \_\_invert\_\_

Python 中还有一个较为特殊的一元运算符abs(), 取绝对值操作符，对应的是特殊方法 \_\_abs\_\_

支持一元运算符很简单，只需要实现相应的特殊方法。这些特殊方法只有一个参数self。需要遵循的基本规则是始终返回一个新对象，也就是说不能修改self， 而是要创建并返回合适类型的新实例。

一般来说， \-，\+ 返回与self同一类型的实例。abs一般返回一个标量。对于~来说，很难说什么结果是合理的，例如ORM中SQL WHERE语句取反就应该返回反集。

#### 13.3  为Vector重载向量加法运算符\+
之前的章节中我们实现过向量Vector 现在为它实现运算符重载

> 序列应当支持\+运算符(用于拼接)， 以及\*运算符(用于重复复制)

然而我们要做的是，为向量实现向量加法和向量乘法运算(点乘)

我们想象中的向量加法应该实现下面两点:

- 对于两个维度相同的向量， 分量分别相加
- 对于两个维度不同的向量，分量少的尾部补零向量再相加

基于以上两点，可以初步写出相应的特殊方法:

```python
def __add__(self, other):
    pairs = itertools.zip_longest(self, other, fillvalue=0.0)
    return Vector(a+b for a,b in pairs)
```

**需要注意的点**： 实现医院运算符和中缀运算符的特殊方法一定不能修改操作数，这些操作符理应返回新对象，只有增量赋值表达式可能修改第一个操作数。

为了支持涉及不同类型的运算， Python 为中缀运算符特殊方法提供了特殊的分派机制 ， 对于表达式a\+b来说，解释器会执行以下几步操作

- 如果a有\_\_add\_\_方法， 而且返回值不是NotImplemented, 调用a.\_\_add\_\_(b)
- 如果没有\_\_add\_\_方法， 或者\_\_add\_\_方法返回NotImplemented, 检查b有没有\_\_radd\_\_， 如果有且返回不是NotImplemented，返回b.\_\_radd\_\_(a)
- 如果b没有\_\_radd\_\_或者\_\_radd\_\_返回

